use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use axum::Json;

use crate::api::ApiResponse;

#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Not found: {0}")]
    NotFound(String),

    #[error("Validation: {0}")]
    Validation(String),

    #[error("Conflict: {0}")]
    Conflict(String),

    #[error("Unauthorized: {0}")]
    Unauthorized(String),

    #[error("Forbidden: {0}")]
    Forbidden(String),

    #[error("Internal error")]
    Internal(#[source] anyhow::Error),

    #[error("Database error")]
    Database(#[source] sea_orm::DbErr),
}

impl AppError {
    pub fn status_code(&self) -> StatusCode {
        match self {
            Self::NotFound(_) => StatusCode::NOT_FOUND,
            Self::Validation(_) => StatusCode::BAD_REQUEST,
            Self::Conflict(_) => StatusCode::CONFLICT,
            Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
            Self::Forbidden(_) => StatusCode::FORBIDDEN,
            Self::Internal(_) | Self::Database(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    pub fn error_code(&self) -> &'static str {
        match self {
            Self::NotFound(_) => "NOT_FOUND",
            Self::Validation(_) => "VALIDATION_ERROR",
            Self::Conflict(_) => "CONFLICT",
            Self::Unauthorized(_) => "UNAUTHORIZED",
            Self::Forbidden(_) => "FORBIDDEN",
            Self::Internal(_) => "INTERNAL_ERROR",
            Self::Database(_) => "DATABASE_ERROR",
        }
    }
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        match &self {
            Self::Internal(err) => tracing::error!("Internal error: {err:#}"),
            Self::Database(err) => tracing::error!("Database error: {err}"),
            _ => {}
        }

        let status = self.status_code();
        let body = Json(ApiResponse::<()>::error(
            self.error_code(),
            self.to_string(),
        ));

        (status, body).into_response()
    }
}

impl From<sea_orm::DbErr> for AppError {
    fn from(err: sea_orm::DbErr) -> Self {
        match &err {
            sea_orm::DbErr::RecordNotFound(msg) => Self::NotFound(msg.clone()),
            sea_orm::DbErr::Query(sea_orm::RuntimeErr::SqlxError(e)) => {
                let msg = e.to_string();
                if msg.contains("23505") {
                    Self::Conflict("A record with this value already exists".into())
                } else if msg.contains("23503") {
                    Self::Validation("Referenced record does not exist".into())
                } else {
                    Self::Database(err)
                }
            }
            _ => Self::Database(err),
        }
    }
}

impl From<anyhow::Error> for AppError {
    fn from(err: anyhow::Error) -> Self {
        Self::Internal(err)
    }
}

pub type AppResult<T> = Result<T, AppError>;
